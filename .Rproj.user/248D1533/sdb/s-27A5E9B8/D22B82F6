{
    "collab_server" : "",
    "contents" : "#' Combine and annotate peaks from different sample types. Optionally merge nearby regions.\n#'\n#' This function accomplishes three tasks:\n#' (1) Combines peaks from different sample types into one master list,\n#'  and annotates each peak with it's sample type-specificity (which cell or\n#'   tissue types the peak can be found in)\n#' (2) Categorizes peaks as either TSS-proximal or TSS-distal based on the distance\n#' from a known transcription start site (TSS).  By defaul, distance is set to\n#' 1500 bp but can be changed with the distancefromTSS argument).\n#' (3) Optionally, regulatory regions that are within a certain distance of\n#'  each other can be merged to form a larger regulatory region.\n#'\n#'\n#' @param conspeaks list of GRanges objects for each sample type\n#'  (output by getConsensusPeaks() function)\n#' @param TSS file of transcription start sites\n#' @param distancefromTSS in bp; peaks within distFromTSS of an annotated\n#' Transcription Start Site (TSS) will be annotated as TSS-proximal (default=1500bp)\n#' @param merge whether or not regions should be merged if they are within a\n#' user set distance to each other (default is FALSE)\n#' @param regionspecific logical to if TRUE, merging occurs within same type\n#'  peaks (e.g. merge TSS-proximal, then merge TSS-distal)\n#' @param mergedist merge TSS-proximal and TSS-distal if they are < mergedist apart\n#'  (set when regionspecific is FALSE)\n#' @param distancefromTSSprox merge TSS-proximal if they are < distancefromTSSprox apart\n#'  (set when regionspecific is TRUE)\n#' @param distancefromTSSdist merge TSS-distal peaks if they are < distancefromTSSdist apart\n#'  (set when regionspecific is TRUE)\n#'\n#' @return List containing two items:\n#' (1) GRanges object:  all sample types combined, regions annotated as\n#'  type-specific and TSS-distal/TSS-proximal specific.\n#' (2) Matrix: number and size of TSS-distal and TSS-proximal before and\n#'  after merging nearby regulatory regions\n#'\n#'\n#' @examples\n#' \\dontrun{\n#' csvfile <- loadCSVFile(\"DNAseEncodeExample.csv\")\n#' samplePeaks <- loadBedFiles(csvfile)\n#' consensusPeaks <- getConsensusPeaks(samplepeaks = samplePeaks, minreps = 2)\n#' TSSannot <- getTSS()\n#' consensusPeaksAnnotated <- combineAnnotatePeaks(conspeaks = consensusPeaks,\n#'    TSS = TSSannot,\n#'    merge = TRUE,\n#'    regionspecific = TRUE,\n#'    distancefromTSSdist = 1500,\n#'    distancefromTSSprox = 1000)\n#'}\n#' @export\n\ncombineAnnotatePeaks <- function(conspeaks,\n                                 TSS,\n                                 merge = FALSE,\n                                 distancefromTSSdist = 0,\n                                 distancefromTSSprox = 0,\n                                 mergedist = 0,\n                                 regionspecific = NA,\n                                 distancefromTSS = 1500) {\n  if (class(conspeaks[[1]])[1] != \"GRangesList\") {\n    stop(\"The input conspeaks is not in the correct format!\n         (try to rerun getConsensusPeaks())\")\n  }\n\n  peaklist <- conspeaks[[1]]\n\n  ################################# Aggregate and combine consensus peaks from\n  ################################# all sample types\n  allregregions <- c(peaklist[[1]])\n  for (i in 2:length(peaklist)) {\n    allregregions <- c(allregregions, peaklist[[i]])\n  }\n  reducedallregregions <- reduce(allregregions)\n\n  TSSgranges <- tssannotgrange(reducedallregregions,\n                               TSS, distancefromTSS)\n\n  ################################# Annotate combined peaks (TSSgranges) by the\n  ################################# cell type they came from\n\n  # If merge is set to false, don't merge\n  if (merge == FALSE)\n  {\n    if (distancefromTSSdist > 0 || distancefromTSSprox >\n        0) {\n      mergestats <- as.data.frame(\"No merging because merge is set to FALSE\")\n    } else {\n      mergestats <- as.data.frame(\"No merging because distancefromTSSdist\n                                  and distancefromTSSprox were set to zero\")\n    }\n    namesvector <- c()\n    for (i in 1:length(peaklist)) {\n      newgranges <- peaklist[[i]]\n      name <- as.character(unique(mcols(newgranges)[1])[1, 1])\n      namesvector <- c(namesvector, name)\n    }\n\n    for (i in 1:length(peaklist)) {\n      typespecific <- findOverlaps(TSSgranges,\n                                   peaklist[[i]])\n      newdataframe <- data.frame(matrix(nrow = length(TSSgranges)))\n      newdataframe[queryHits(typespecific), 1] <- namesvector[i]\n      values(TSSgranges) <- cbind(values(TSSgranges), newdataframe)\n      colnames(mcols(TSSgranges))[i + 1] <- c(namesvector[i])\n    }\n\n    # this will annotate the regions with\n    # type-specificity\n    notmerging <- grangestodataframe(TSSgranges)\n    listtoreturn <- list(consPeaksAnnotated =\n                           GRanges(notmerging,\n                                   meta = notmerging[, 4:ncol(notmerging)]),\n                         mergestats = mergestats)\n  }  # end if no merging\n  else {\n    # Do the merging\n    if (is.na(regionspecific)) {\n      stop(\"If merging, then the regionspecific paramater must\n           be set to TRUE or FALSE\")\n    }\n    # if merging TSS-distal and TSS-proximal regions\n    # seperately, then run the merging function on\n    # them seperately and then combine them\n    # (WITHOUT reducing or you will lose the\n    # annotation)\n    if (regionspecific == TRUE) {\n      if (is.na(distancefromTSSprox) || is.na(distancefromTSSdist)) {\n        stop(\"If regionspecific is true,\n             then distancefromTSSprox and distancefromTSSdist must be set\")\n      }\n      dataframeformerge <- grangestodataframe(TSSgranges)\n      TSSdistalbeforemergedata <- dataframeformerge[dataframeformerge$region ==\n                                                     \"TSS-distal\", ]\n      TSSproxbeforemergedata <- dataframeformerge[dataframeformerge$region ==\n                                                     \"TSS-proximal\", ]\n\n      # Merge TSS-distal and TSS-proximal independently\n      # if they're within user defined distances\n      TSSdistafter <- mergeclosepeaks(peaklist,\n                                       TSSdistalbeforemergedata,\n                                       mergedist = distancefromTSSdist,\n                                       TSS, distancefromTSS)\n      TSSproxafter <- mergeclosepeaks(peaklist,\n                                       TSSproxbeforemergedata,\n                                       mergedist = distancefromTSSprox,\n                                       TSS, distancefromTSS)\n\n      bothafter <- sort(GenomeInfoDb::sortSeqlevels(c(TSSdistafter,\n                                        TSSproxafter)))\n    }\n\n    # if merging TSS-distal and TSS-proximal regions at\n    # the same time, then you just need to run the\n    # function once\n    if (regionspecific == FALSE) {\n      if (is.na(mergedist)) {\n        stop(\"If regionspecific is FALSE, then mergedist must be set\")\n      }\n      dataframeformerge <- grangestodataframe(TSSgranges)\n      # create grange from dataframe\n\n      bothafter <- mergeclosepeaks(peaklist,\n                                   dataframeformerge,\n                                   mergedist,\n                                   TSS, distancefromTSS)\n    }\n\n    # Create matrix for comparison:\n    resultuserinput <- grangestodataframe(bothafter)\n\n    tableofinfo <- matrix(nrow = 4, ncol = 2)\n    rownames(tableofinfo) <- c(\"TSS-distal_before_merging\",\n                               \"TSS-distal_after_merging\",\n                               \"TSS-proximal_before_merging\",\n                               \"TSS-proximal_after_merging\")\n    colnames(tableofinfo) <- c(\"TotalNumber\", \"MeanLength\")\n\n    # Callstatscombineannotate internal function\n    # to create table:\n    tableofinfo <- statscombineannotate(tableofinfo, dataframeformerge, 1, 3)\n    tableofinfo <- statscombineannotate(tableofinfo, resultuserinput, 2, 4)\n\n    ### quick fix\n    tableofinfo <- as.data.frame(tableofinfo)\n    tableofinfo$Condition <- rownames(tableofinfo)\n    tableofinfo <- tableofinfo[ , c(3,1,2)]\n    rownames(tableofinfo) <- NULL\n    ##\n    #tableofinfo <- plyr::name_rows(as.data.frame(tableofinfo))[ , c(3,1,2)]\n    #colnames(tableofinfo)[1] <- \"Condition\"\n    ###\n\n    listtoreturn <- list(consPeaksAnnotated =\n                           GRanges(resultuserinput,\n                                   meta = resultuserinput[ , 4:ncol(\n                                     resultuserinput)]),\n                         mergestats = tableofinfo)\n  }\n  return(listtoreturn)\n}\n\n\n",
    "created" : 1472654498581.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2875778080",
    "id" : "D22B82F6",
    "lastKnownWriteTime" : 1472654672,
    "last_content_update" : 1472654672505,
    "path" : "~/Desktop/ALTRE/R/3_getannotation.R",
    "project_path" : "R/3_getannotation.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}
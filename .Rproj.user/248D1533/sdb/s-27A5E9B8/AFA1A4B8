{
    "collab_server" : "",
    "contents" : "#' Given the output from getConsensusPeaks, generate a barplot\n#' of countstatistics\n#'\n#' @param samplepeaks output generated from getConsensusPeaks\n#' @param palette RColorBrewer palette to change graph colors\n#' @return a highcharter object\n#'\n#' @examples\n#' \\dontrun{\n#' csvfile <- loadCSVFile(\"DNAseEncodeExample.csv\")\n#' samplePeaks <- loadBedFiles(csvfile)\n#' consensusPeaks <- getConsensusPeaks(samplepeaks = samplePeaks,\n#' minreps = 2)\n#' plotConsensusPeaks(samplepeaks = consensusPeaks)}\n#' @export\n#'\nplotConsensusPeaks <- function(samplepeaks, palette = \"Set1\") {\n\n  cols <- RColorBrewer::brewer.pal(3, palette)\n\n\n  CellType <- NULL\n  #without this R CMD check throws no visible binding for global variable error\n\n  consPeaksStats <- samplepeaks$consPeaksStats\n  row.names(consPeaksStats) <- NULL\n  consPeaksStats[ , 2] <-  as.numeric(as.character(consPeaksStats[[2]]))\n  consPeaksStats[ , 3] <-  as.numeric(as.character(consPeaksStats[[3]]))\n  statsFormated <- tidyr::gather(consPeaksStats, \"CellType\", \"Count\", 2:3)\n\n  plottingData <- statsFormated %>%\n    split(levels(as.factor(statsFormated$CellType)))\n\n  col1 <- cols[1]\n  col2 <- cols[2]\n\n  p <- highchart(height = 700) %>%\n    hc_title(text = \"Peak Counts by Cell Type\",\n             style = list(color = '#2E1717',\n                          fontWeight = 'bold')) %>%\n    hc_subtitle(text = \"For bioreplicates and their merged consensus track\") %>%\n    hc_add_series(\n      color = col1,\n      data = plottingData[[1]]$Count,\n      name = names(plottingData[1]),\n      type = \"column\",\n      dataLabels = list(\n        enabled = TRUE,\n        rotation = 270,\n        color = '#FFFFFF',\n        y = 40\n      )\n    ) %>%\n    hc_add_series(\n      color = col2,\n      data = plottingData[[2]]$Count,\n      name = names(plottingData[2]),\n      dataLabels = list(\n        enabled = TRUE,\n        rotation = 270,\n        color = '#FFFFFF',\n        y = 40\n      ),\n      type = \"column\"\n    ) %>%\n    hc_yAxis(title = list(text = \"Peak Counts\"),\n             labels = list(format = \"{value}\")) %>%\n    hc_xAxis(categories = plottingData[[1]]$PeakType) %>%\n    hc_legend(\n      enabled = TRUE,\n      layout = \"horizonal\",\n      align = \"center\",\n      verticalAlign = \"bottom\",\n      floating = FALSE,\n      maxHeight = 100,\n      x = 15,\n      y = 16\n    ) %>%\n    hc_tooltip(\n      headerFormat = \"<b>{series.name}_{point.key}</b><br>\",\n      pointFormat = \"{point.y}\",\n      valueSuffix = ' peaks'\n    ) %>%\n    hc_exporting(enabled = TRUE)\n  return(p)\n}\n\n####################################################################\n\n#' Given the output from combineAnnotatePeaks,\n#' plot a barplot showing number of peaks before/after merging or length of\n#' peaks before/after merging\n#' (only works if peaks were merged)\n#'\n#' @param conspeaks output generated from combineAnnotatePeaks\n#' @param palette RColorBrewer palette to change graph colors\n#' @param viewer whether the plot should be displayed in the RStudio viewer or\n#'        in Shiny/Knittr\n#' @return a highcharter object\n#'\n#' @examples\n#' \\dontrun{\n#' csvfile <- loadCSVFile(\"DNAseEncodeExample.csv\")\n#' samplePeaks <- loadBedFiles(csvfile)\n#' consensusPeaks <- getConsensusPeaks(samplepeaks = samplePeaks,\n#' minreps = 2)\n#' TSSannot <- getTSS()\n#' consensusPeaksAnnotated <- combineAnnotatePeaks(conspeaks = consensusPeaks,\n#' TSS = TSSannot,\n#' merge = TRUE,\n#' regionspecific = TRUE,\n#' distancefromTSSdist = 1500,\n#' distancefromTSSprox = 1000)\n#' plotCombineAnnotatePeaks(consensusPeaksAnnotated)\n#' }\n#' @export\n#'\nplotCombineAnnotatePeaks <- function(conspeaks, viewer = TRUE,\n                                     palette = \"Set1\") {\n\n    cols <- RColorBrewer::brewer.pal(3, palette)\n    CellType <- NULL\n    #R CMD check throws no visible binding for global variable error\n\n    mergeStats <- conspeaks$mergestats\n    row.names(mergeStats) <- NULL\n    mergeStats[ , 2] <-  as.numeric(as.character(mergeStats[[2]]))\n    mergeStats[ , 3] <-  as.numeric(as.character(mergeStats[[3]]))\n    mergeStatsFormatted <- tidyr::gather(mergeStats, \"CellType\", \"Count\", 2:3)\n\n\n    if ( nrow(mergeStatsFormatted) == 1 ) {\n        stop(\"No plot to show since merging was not performed\n             when calling combineAnnotatePeaks function\")\n    }\n\n\n    feature <- \"TotalNumber\"\n    if ( feature == \"TotalNumber\") {\n        mergeStatsTotal <- dplyr::filter(mergeStatsFormatted,\n                                         CellType == \"TotalNumber\")\n        thecondition <- matrix(unlist(strsplit(mergeStatsTotal$Condition, \"_\")),\n                               nrow = 3, ncol = 4)[2,]\n        mergeStatsBefore <- dplyr::filter(mergeStatsTotal,\n                                          thecondition == \"before\")\n        mergeStatsAfter <- dplyr::filter(mergeStatsTotal,\n                                         thecondition == \"after\")\n\n        p1 <- highchart(height = 1000) %>%\n            hc_title(text = \"Number of REs\",\n                     style = list(color = '#2E1717',\n                                  fontWeight = 'bold')) %>%\n            hc_add_series(\n                data = mergeStatsBefore$Count,\n                name = c(\"TSS-distal\"),\n                type = \"column\",\n                dataLabels = list(\n                    enabled = TRUE,\n                    rotation = 270,\n                    color = '#FFFFFF',\n                    y = 40\n                )) %>%\n            hc_add_series(\n                data = mergeStatsAfter$Count,\n                name = c(\"TSS-proximal\"),\n                type = \"column\",\n                dataLabels = list(\n                    enabled = TRUE,\n                    rotation = 270,\n                    color = '#FFFFFF',\n                    y = 40\n                )) %>%\n            hc_yAxis(title = list(text = \"Number of REs\"),\n                     labels = list(format = \"{value}\")) %>%\n            hc_xAxis(categories = c(\"Before Merging\", \"After Merging\")) %>%\n            hc_legend(\n                enabled = TRUE,\n                layout = \"horizontal\",\n                align = \"center\",\n                verticalAlign = \"bottom\",\n                floating = FALSE,\n                maxHeight = 100,\n                x = 0,\n                y = 17\n            ) %>%\n            hc_tooltip(\n                headerFormat = \"<b>{series.name}_{point.key}</b><br>\",\n                pointFormat = \"{point.y}\",\n                valueSuffix = ' peaks'\n            ) %>%\n            hc_colors(cols) %>%\n            hc_exporting(enabled = TRUE)\n\n    }\n\n    feature <- \"MeanLength\"\n    if ( feature == \"MeanLength\" ) {\n      mergeStatsMean <- dplyr::filter(mergeStatsFormatted,\n                                      CellType == \"MeanLength\")\n      thecondition <- matrix(unlist(strsplit(mergeStatsMean$Condition, \"_\")),\n                             nrow = 3,\n                             ncol = 4)[2, ]\n      mergeStatsBefore <- dplyr::filter(mergeStatsMean,\n                                        thecondition == \"before\")\n      mergeStatsAfter <- dplyr::filter(mergeStatsMean,\n                                       thecondition == \"after\")\n\n\n        p2 <- highchart(height = 1000) %>%\n            hc_title(text = \"Mean length of REs\",\n                     style = list(color = '#2E1717',\n                                  fontWeight = 'bold')) %>%\n            hc_add_series(\n                data = mergeStatsBefore$Count,\n                name = c(\"TSS-distal\"),\n                type = \"column\",\n                dataLabels = list(\n                    enabled = TRUE,\n                    rotation = 270,\n                    color = '#FFFFFF',\n                    y = 40\n                )) %>%\n            hc_add_series(\n                data = mergeStatsAfter$Count,\n                name = c(\"TSS-proximal\"),\n                type = \"column\",\n                dataLabels = list(\n                    enabled = TRUE,\n                    rotation = 270,\n                    color = '#FFFFFF',\n                    y = 40\n                )) %>%\n            hc_yAxis(title = list(text = \"Mean Length of REs\"),\n                     labels = list(format = \"{value}\")) %>%\n            hc_xAxis(categories = c(\"Before Merging\", \"After Merging\")) %>%\n            hc_legend(\n                enabled = TRUE,\n                layout = \"horizontal\",\n                align = \"center\",\n                verticalAlign = \"bottom\",\n                floating = FALSE,\n                maxHeight = 100,\n                x = 0,\n                y = 17\n            ) %>%\n            hc_tooltip(\n                headerFormat = \"<b>{series.name}_{point.key}</b><br>\",\n                pointFormat = \"{point.y}\",\n                valueSuffix = ' peaks'\n            ) %>%\n            hc_colors(cols) %>%\n            hc_exporting(enabled = TRUE)\n    }\n\n\n    if (viewer == TRUE) {\n    p <- htmltools::browsable(hw_grid(p1, p2, ncol = 2, rowheight = 550))\n    }\n    else {\n    p <- hw_grid(p1, p2)\n    }\n    return(p)\n}\n\n###############################################################################\n\n\n#' Given the output from getCounts, plot a density plot of\n#' log2 RPKM values of regulation regions\n#'\n#' @param countsConsPeaks output generated from getCounts\n#' @param palette RColorBrewer palette to change graph colors\n#'\n#' @return a highcharter object\n#'\n#' @examples\n#' \\dontrun{\n#' csvfile <- loadCSVFile(\"DNAseEncodeExample.csv\")\n#' samplePeaks <- loadBedFiles(csvfile)\n#' consensusPeaks <- getConsensusPeaks(samplepeaks = samplePeaks,\n#' minreps = 2)\n#' TSSannot <- getTSS()\n#' consensusPeaksAnnotated <- combineAnnotatePeaks(conspeaks = consensusPeaks,\n#' TSS = TSSannot,\n#' merge = TRUE,\n#' regionspecific = TRUE,\n#' distancefromTSSdist = 1500,\n#' distancefromTSSprox = 1000)\n#' consensusPeaksCounts <- getCounts(annotpeaks = consensusPeaksAnnotated,\n#'                                  sampleinfo = csvfile,\n#'                                  reference = 'SAEC',\n#'                                  chrom = 'chr21')\n#' plotGetCounts(consensusPeaksCounts)}\n#' @export\n\nplotGetCounts <- function(countsConsPeaks, palette = \"Set1\") {\n  region <- NULL\n  variable <- NULL\n  #set to null forR CMD Check error: Undefined global functions/variables\n\n  cols <- RColorBrewer::brewer.pal(4, palette)\n\n  mydf <- countsConsPeaks$regioncountsforplot\n  varstack <- suppressMessages(reshape2::melt(mydf))\n  TSSdistal_A549 <- dplyr::filter(varstack, region == \"TSS-distal\"\n                                  & variable == \"A549\")\n  TSSproximal_A549 <- dplyr::filter(varstack, region == \"TSS-proximal\"\n                                    & variable == \"A549\")\n  TSSdistal_SAEC <- dplyr::filter(varstack, region == \"TSS-distal\"\n                                  & variable == \"SAEC\")\n  TSSproximal_SAEC <- dplyr::filter(varstack, region == \"TSS-proximal\"\n                                    & variable == \"SAEC\")\n\n  p <- hchart(stats::density(TSSdistal_A549$value), area = TRUE,\n              name = \"A549 TSS-distal\") %>%\n    hc_title(text = \"Density of log2 read counts\n             (normalized by library and region sizes)\",\n             style = list(color = '#2E1717',\n                          fontWeight = 'bold')) %>%\n    hc_yAxis(title = \"density\") %>%\n    hc_xAxis(title = \"log2 read counts\") %>%\n    hc_add_series_density(stats::density(TSSproximal_A549$value),\n                          area = TRUE, name = \"A549 TSS-proximal\") %>%\n    hc_add_series_density(stats::density(TSSdistal_SAEC$value),\n                          area = TRUE, name = \"SAEC TSS-distal\") %>%\n    hc_add_series_density(stats::density(TSSproximal_SAEC$value),\n                          area = TRUE, name = \"SAEC TSS-proximal\") %>%\n    hc_colors(cols) %>%\n    hc_exporting(enabled = TRUE)\n  return(p)\n}\n\n\n#' Create a volcano plot from the output of categAltrePeaks\n#'\n#' @param altrepeakscateg output generated from countanalysis() then\n#' categAltrePeaks()\n#' @param viewer whether the plot should be displayed in the RStudio viewer or\n#'        in Shiny/Knittr\n#' @param palette RColorBrewer palette to change graph colors\n\n#'\n#' @return a highcharter object\n#'\n#' @examples\n#' \\dontrun{\n#' csvfile <- loadCSVFile(\"DNAseEncodeExample.csv\")\n#' samplePeaks <- loadBedFiles(csvfile)\n#' consensusPeaks <- getConsensusPeaks(samplepeaks = samplePeaks,\n#' minreps = 2)\n#' TSSannot <- getTSS()\n#' consensusPeaksAnnotated <- combineAnnotatePeaks(conspeaks = consensusPeaks,\n#' TSS = TSSannot,\n#' merge = TRUE,\n#' regionspecific = TRUE,\n#' distancefromTSSdist = 1500,\n#' distancefromTSSprox = 1000)\n#' consensusPeaksCounts <- getCounts(annotpeaks = consensusPeaksAnnotated,\n#'                                  sampleinfo = csvfile,\n#'                                  reference = 'SAEC',\n#'                                  chrom = 'chr21')\n#' alteredPeaks <- countanalysis(counts = consensusPeaksCounts,\n#' pval = 0.01,\n#' lfcvalue = 1)\n#' alteredPeaksCategorized <- categAltrePeaks(alteredPeaks,\n#'                                           lfctypespecific = 1.5,\n#'                                           lfcshared = 1.2,\n#'                                           pvaltypespecific = 0.01,\n#'                                           pvalshared = 0.05)\n#' plotCountAnalysis(alteredPeaksCategorized)\n#' }\n#' @export\n\nplotCountAnalysis <- function(altrepeakscateg, viewer = TRUE, palette = NULL ) {\n\n\n  if ( !is.null(palette) ) {\n    cols <- RColorBrewer::brewer.pal(4, palette) }\n  else{cols <- c(\"#d3d3d3\", \"#C71585\", \"#00E5EE\",\"#000080\")}\n                        #grey (ambiguous)\n                        #magenta (experiment-specific)\n                        #blue (reference specific)\n  #blue (shared)\n\n  log2FoldChange <- NULL\n  padj <- NULL\n  REaltrecateg <- NULL\n  #To prevent R CMD check error\n\n  colnames(altrepeakscateg$analysisresults)\n\n  toplot <- altrepeakscateg$analysisresults[ ,c(\"region\",\n                                                \"log2FoldChange\",\n                                                \"padj\",\n                                                \"REaltrecateg\")]\n  tssdist <- toplot[which(toplot$region == \"TSS-distal\"), ]\n  tssdist$padj <- round(-log10(tssdist$padj), 2)\n  tssdist$log2FoldChange <- round(tssdist$log2FoldChange, 2)\n  tssprox <- toplot[which(toplot$region == \"TSS-proximal\"), ]\n  tssprox$padj <- round(-log10(tssprox$padj), 2)\n  tssprox$log2FoldChange <- round(tssprox$log2FoldChange, 2)\n  lengthRE <- rep(\"\", length(tssdist$REaltrecateg))\n\n  p1 <- highchart() %>%\n    hc_chart(type = \"scatter\") %>%\n    hc_title(text = \"TSS-distal\",\n             style = list(color = '#2E1717',\n                          fontWeight = 'bold')) %>%\n    hc_add_series_df(data = tssdist, x = log2FoldChange, y = padj,\n                     type = \"scatter\", group = REaltrecateg)  %>%\n    hc_xAxis(title = list(text = \"log2fold change\")) %>%\n    hc_yAxis(title = list(text = \"-log10 pvalue\")) %>%\n    hc_tooltip(headerFormat = \"\",\n               pointFormat  = \"<b>log2FC</b> = {point.x}<br> <b>-log10pvalue</b>\n               = {point.y}<br>\") %>%\n    hc_colors(cols) %>%\n    hc_exporting(enabled = TRUE)\n\n  lengthRE <- rep(\"\", length(tssprox$REaltrecateg))\n\n  num1 <- min(which(tssprox$REaltrecateg == \"Experiment Specific\"))\n  num2 <- min(which(tssprox$REaltrecateg == \"Reference Specific\"))\n  num3 <- min(which(tssprox$REaltrecateg == \"Shared\"))\n  num4 <- min(which(tssprox$REaltrecateg == \"Ambiguous\"))\n\n  lengthRE[num1] <- \"Experiment Specific\"\n  lengthRE[num2] <- \"Reference Specific\"\n  lengthRE[num3] <- \"Shared\"\n  lengthRE[num4] <- \"Ambiguous\"\n\n\n  p2 <- highchart() %>%\n    hc_chart(type = \"scatter\") %>%\n    hc_title(text = \"TSS-proximal\",\n             style = list(color = '#2E1717',\n                          fontWeight = 'bold')) %>%\n    hc_add_series_df(data = tssprox, x = log2FoldChange, y = padj,\n                     type = \"scatter\", group = REaltrecateg)  %>%\n    hc_xAxis(title = list(text = \"log2fold change\")) %>%\n    hc_yAxis(title = list(text = \"-log10 pvalue\")) %>%\n    hc_tooltip(headerFormat = \"\",\n               pointFormat  = \"<b>log2FC</b> = {point.x}<br> <b>-log10pvalue</b>\n               = {point.y}<br>\") %>%\n    hc_colors(cols) %>%\n    hc_exporting(enabled = TRUE)\n\n\n  if (viewer == TRUE) {\n    p <- htmltools::browsable(hw_grid(p1, p2, ncol = 2, rowheight = 700))\n  }\n  else {\n    p <- hw_grid(p1, p2, ncol = 2)\n  }\n  return(p)\n}\n\n\n###############################################################################\n#' Creates a boxplot to see the distribution of read counts in type-specific and\n#' shared TSS-proximal and TSS-distal regions.\n#'\n#' Takes the rlog transformation of the RRKM (Reads Per Kilobase of transcript\n#' per Million) of the read counts of type-specific and shared regulatory\n#' regions and plots the distribution of those read counts in all sample types\n#' analyzed in the workflow.\n#'\n#' @param analysisresults output generated from countanalysis() then\n#' categAltrePeaks()\n#' @param counts output generated from getCounts()\n#' @param palette RColorBrewer palette to change graph colors\n#' @return a highcharter object\n#'\n#' @examples\n#' \\dontrun{\n#' csvfile <- loadCSVFile(\"DNAseEncodeExample.csv\")\n#' samplePeaks <- loadBedFiles(csvfile)\n#' consensusPeaks <- getConsensusPeaks(samplepeaks = samplePeaks,\n#' minreps = 2)\n#' TSSannot <- getTSS()\n#' consensusPeaksAnnotated <- combineAnnotatePeaks(conspeaks = consensusPeaks,\n#' TSS = TSSannot,\n#' merge = TRUE,\n#' regionspecific = TRUE,\n#' distancefromTSSdist = 1500,\n#' distancefromTSSprox = 1000)\n#' consensusPeaksCounts <- getCounts(annotpeaks = consensusPeaksAnnotated,\n#'                                  sampleinfo = csvfile,\n#'                                  reference = 'SAEC',\n#'                                  chrom = 'chr21')\n#' alteredPeaks <- countanalysis(counts = consensusPeaksCounts,\n#' pval = 0.01,\n#' lfcvalue = 1)\n#' alteredPeaksCategorized <- categAltrePeaks(alteredPeaks,\n#'                                           lfctypespecific = 1.5,\n#'                                           lfcshared = 1.2,\n#'                                           pvaltypespecific = 0.01,\n#'                                           pvalshared = 0.05)\n#' plotDistCountAnalysis(alteredPeaksCategorized, consensusPeaksCounts)\n#' }\n#' @export\n#'\nplotDistCountAnalysis <- function(analysisresults, counts, palette = NULL){\n\n  if ( !is.null(palette) ) {\n    cols <- RColorBrewer::brewer.pal(4, palette) }\n  else{cols <- c(\"#C71585\", \"#d3d3d3\", \"#000080\", \"#00E5EE\")}\n           #magenta (experiment-specific) #grey (ambiguous) #blue (shared))\n  #blue (reference specific)\n\n  readcounts <- counts$regioncounts\n  analysisresults <- analysisresults[[1]]\n  errortest = try(SummarizedExperiment::assay(readcounts), silent = TRUE)\n  if (inherits(errortest, 'try-error') == TRUE) {\n    stop(\"The input for the readcounts arguement is\n         not a summerized experiment object!\")\n  }\n\n  if (is.data.frame(analysisresults) == FALSE)\n  {\n    stop(\"The input for the analysisresults arguement is not a dataframe!\")\n\n  }\n\n  # Check that counts and analysisresults are in the same order\n  countsinfo <- as.data.frame(SummarizedExperiment::rowRanges(readcounts))\n  countcoord <- paste0(countsinfo$seqnames, countsinfo$start, countsinfo$end)\n  analcoord <- paste0(analysisresults$chr,\n                     analysisresults$start,\n                     analysisresults$stop)\n\n  if (!all.equal(analcoord, countcoord)) {\n    stop(\"The peaks in the analysisresults and counts are not the same\")\n  }\n\n  PEcateg <- analysisresults$region\n  altrecateg <- analysisresults$REaltrecateg\n\n  # Get log2FPM values:\n  log2FPM <- log2(DESeq2::fpkm(readcounts, robust = TRUE) + 0.001)\n\n  # Average log2FPM values over replicats:\n  sampletypes <- SummarizedExperiment::colData(readcounts)$sample\n  meanlog2FPM <- c()\n\n  for (i in unique(sampletypes)) {\n    samp <- which(sampletypes == i)\n    meanlog2FPM <- cbind(meanlog2FPM,\n                        as.numeric(apply(log2FPM[, samp], 1, mean)))\n  }\n  colnames(meanlog2FPM) <- unique(sampletypes)\n\n  mydf <- data.frame(meanlog2FPM = meanlog2FPM,\n                    PEcateg = PEcateg,\n                    altrecateg = altrecateg)\n  TSSdistal <- dplyr::filter(mydf, PEcateg == \"TSS-distal\")\n  distal1 <- dplyr::filter(mydf, altrecateg == \"Experiment Specific\")\n  distal2 <- dplyr::filter(mydf, altrecateg == \"Ambiguous\")\n  distal3 <- dplyr::filter(mydf, altrecateg == \"Shared\")\n  distal4 <- dplyr::filter(mydf, altrecateg == \"Reference Specific\")\n\n  TSSproximal <- dplyr::filter(mydf, PEcateg == \"TSS-proximal\")\n  proximal1 <- dplyr::filter(mydf, altrecateg == \"Experiment Specific\")\n  proximal2 <- dplyr::filter(mydf, altrecateg == \"Ambiguous\")\n  proximal3 <- dplyr::filter(mydf, altrecateg == \"Shared\")\n  proximal4 <- dplyr::filter(mydf, altrecateg == \"Reference Specific\")\n\n  distal1_5num_A549 <- stats::fivenum(distal1$meanlog2FPM.A549)\n  proximal1_5num_A549 <- stats::fivenum(proximal1$meanlog2FPM.A549)\n  distal1_5num_SAEC <- stats::fivenum(distal1$meanlog2FPM.SAEC)\n  proximal1_5num_SAEC <- stats::fivenum(proximal1$meanlog2FPM.SAEC)\n\n  distal2_5num_A549 <- stats::fivenum(distal2$meanlog2FPM.A549)\n  proximal2_5num_A549 <- stats::fivenum(proximal2$meanlog2FPM.A549)\n  distal2_5num_SAEC <- stats::fivenum(distal2$meanlog2FPM.SAEC)\n  proximal2_5num_SAEC <- stats::fivenum(proximal2$meanlog2FPM.SAEC)\n\n  distal3_5num_A549 <- stats::fivenum(distal3$meanlog2FPM.A549)\n  proximal3_5num_A549 <- stats::fivenum(proximal3$meanlog2FPM.A549)\n  distal3_5num_SAEC <- stats::fivenum(distal3$meanlog2FPM.SAEC)\n  proximal3_5num_SAEC <- stats::fivenum(proximal3$meanlog2FPM.SAEC)\n\n  distal4_5num_A549 <- stats::fivenum(distal4$meanlog2FPM.A549)\n  proximal4_5num_A549 <- stats::fivenum(proximal4$meanlog2FPM.A549)\n  distal4_5num_SAEC <- stats::fivenum(distal4$meanlog2FPM.SAEC)\n  proximal4_5num_SAEC <- stats::fivenum(proximal4$meanlog2FPM.SAEC)\n\n  Experimentspecific_list <- list(round(distal1_5num_A549,3),\n                                  round(proximal1_5num_A549, 3),\n                                  round(distal1_5num_SAEC,3),\n                                  round(proximal1_5num_SAEC,3))\n  Ambiguous_list <- list(round(distal2_5num_A549,3),\n                         round(proximal2_5num_A549,3),\n                         round(distal2_5num_SAEC,3),\n                         round(proximal2_5num_SAEC,3))\n  Shared_list <- list(round(distal3_5num_A549,3),\n                      round(proximal3_5num_A549,3),\n                      round(distal3_5num_SAEC,3),\n                      round(proximal3_5num_SAEC,3))\n  Referencespecific_list <- list(round(distal4_5num_A549,3),\n                                 round(proximal4_5num_A549,3),\n                                 round(distal4_5num_SAEC,3),\n                                 round(proximal4_5num_SAEC,3))\n\n  categ <- c('A549-specific TSS-distal', 'A549-specific TSS-proximal',\n             'SAEC-specific TSS-distal', 'SAEC-specific TSS-proximal')\n  p <- highchart() %>%\n    hc_title(text = \"Distribution of Normalized Counts\",\n             style = list(color = '#2E1717',\n                          fontWeight = 'bold')) %>%\n    hc_plotOptions(\n      boxplot = list(\n        fillColor = '#ffffff',\n        lineWidth = 2,\n        medianColor = '#000000',\n        medianWidth = 2,\n        stemColor = '#000000',\n        stemDashStyle = 'dot',\n        stemWidth = 1,\n        whiskerColor = '#000000',\n        whiskerLength = '20%',\n        whiskerWidth = 3\n      )\n    ) %>%\n    hc_add_series(data = Experimentspecific_list,\n                  name = 'Experiment Specific',\n                  type = \"boxplot\") %>%\n    hc_add_series(data = Ambiguous_list,\n                  name = 'Ambiguous',\n                  type = \"boxplot\") %>%\n    hc_add_series(data = Shared_list,\n                  name = 'Shared',\n                  type = \"boxplot\") %>%\n    hc_add_series(data = Referencespecific_list,\n                  name = 'Reference Specific',\n                  type = \"boxplot\") %>%\n    hc_yAxis(title = list(text = \"Observations\"),\n             labels = list(format = \"{value}\")) %>%\n    hc_xAxis(categories = categ, title = \"Experiment No.\") %>%\n    hc_tooltip(headerFormat = \"<b>{point.key}</b><br>\",\n               pointFormat = \"{point.y}\") %>%\n    hc_colors(cols) %>%\n    hc_exporting(enabled = TRUE)\n    return(p)\n}\n\n##############################################################################\n\n#' Given the output from enrichment(), creates a heatmap from\n#' the ouput of the enrichment analysis. Presence or absence of\n#' the pathway in enrichment of both type-specific (increased or decreased\n#' log2fold change, low p-value) and shared (no change, higher p-value)\n#' regulatory regions is plotted.\n#'\n#' @param input results from enrichment analysis\n#' @param title title of the heatmap\n#' @param pvalfilt p-value cut-off for inclusion in heatmap\n#' @param removeonlyshared removes regions that come up signifigant only shared\n#' regulatory regions when set to TRUE. Default is FALSE.\n#' @param numshow number of top pathways (ranked according to p-value) of each\n#' type (expt, reference, shared) to show in the plot (default=10)\n#'\n#' @return heatmap\n#'\n#' @examples\n#' \\dontrun{\n#' csvfile <- loadCSVFile(\"DNAseEncodeExample.csv\")\n#' samplePeaks <- loadBedFiles(csvfile)\n#' consensusPeaks <- getConsensusPeaks(samplepeaks = samplePeaks,\n#' minreps = 2)\n#' TSSannot <- getTSS()\n#' consensusPeaksAnnotated <- combineAnnotatePeaks(conspeaks = consensusPeaks,\n#' TSS = TSSannot,\n#' merge = TRUE,\n#' regionspecific = TRUE,\n#' distancefromTSSdist = 1500,\n#' distancefromTSSprox = 1000)\n#' consensusPeaksCounts <- getCounts(annotpeaks = consensusPeaksAnnotated,\n#'                                  sampleinfo = csvfile,\n#'                                  reference = 'SAEC',\n#'                                  chrom = 'chr21')\n#' alteredPeaks <- countanalysis(counts = consensusPeaksCounts,\n#' pval = 0.01,\n#' lfcvalue = 1)\n#' alteredPeaksCategorized <- categAltrePeaks(alteredPeaks,\n#'                                           lfctypespecific = 1.5,\n#'                                           lfcshared = 1.2,\n#'                                           pvaltypespecific = 0.01,\n#'                                           pvalshared = 0.05)\n#' MFenrich <- pathenrich(analysisresults = alteredPeaksCategorized,\n#' ontoltype = 'MF',\n#' enrichpvalfilt = 0.99)\n#' enrichHeatmap(MFenrich, title = \"TSS-distal GO:MF\", pvalfilt = 0.99)\n#' }\n#' @export\n\nenrichHeatmap <- function(input,\n                          title,\n                          pvalfilt = 0.01,\n                          removeonlyshared = FALSE,\n                          numshow=10) {\n  # input=input[[1]]\n\n  if (is.list(input) == FALSE) {\n    stop(\"The input is not a list! Please make sure you are\n         using the output from the enrichment analysis\")\n  }\n\n  if (is.data.frame(input$expt) == FALSE |\n      is.data.frame(input$reference) == FALSE |\n      is.data.frame(input$shared) == FALSE |\n      length(input) != 3 |\n      all(names(input) != c(\"expt\", \"reference\", \"shared\"))) {\n    stop(\"The input is not a list of three dataframes or\n         there are no enriched pathways to plot\")\n  }\n\n  up <- input$expt\n  if (length(up) <= 1) {\n    up$Description <- NA\n  } else {\n    up <- up[up$p.adjust < pvalfilt, ]\n    if ( nrow(up) > numshow ) {\n      up <- up[order(up$p.adjust)[1:numshow],]\n    }\n  }\n  reference <- input$reference\n  if (length(reference) <= 1) {\n    reference$Description <- NA\n  } else {\n    reference <- reference[reference$p.adjust < pvalfilt, ]\n    if ( nrow(reference) > numshow) {\n      reference <- reference[order(reference$p.adjust)[1:numshow],]\n    }\n  }\n  shared <- input$shared\n  if (length(shared) <= 1) {\n    shared$Description <- NA\n  } else {\n    shared <- shared[shared$p.adjust < pvalfilt, ]\n    if ( nrow(shared) > numshow ) {\n      shared <- shared[order(shared$p.adjust)[1:numshow],]\n    }\n  }\n\n  pathways <- unique(c(up$Description,\n                       reference$Description,\n                       shared$Description))\n  #print(paste(\"Pathways\", pathways))\n  pathways <- pathways[!is.na(pathways)]\n  if (is.na(pathways) || length(pathways) == 0) {\n    stop(\"No pathways are significant\n         (with adjusted pvalues < user input cutoff)\")\n  }\n  # make a list of all the pathways in up, down, and shared\n  heatmapmatrix <- matrix(data = NA,\n                          nrow = length(pathways),\n                          ncol = 3)\n  # make a matrix with as many row as there are pathways\n  row.names(heatmapmatrix) <- pathways\n  # name the rows with the pathway names\n\n  colnames(heatmapmatrix) <- c(\"up\", \"down\", \"shared\")\n  # put up, down, and shared as the pathway names\n\n  #print(paste(\"Dim heatmapmatrix\", dim(heatmapmatrix)))\n\n  for (i in 1:length(row.names(heatmapmatrix))) {\n    #print(row.names(heatmapmatrix)[i])\n    if (row.names(heatmapmatrix)[i] %in% up$Description) {\n      num1 <- which(up$Description == row.names(heatmapmatrix)[i])\n      heatmapmatrix[i, 1] <- up[num1, 6]\n    }\n\n    if (row.names(heatmapmatrix)[i] %in% reference$Description) {\n      num2 <- which(reference$Description == row.names(heatmapmatrix)[i])\n      heatmapmatrix[i, 2] <- reference[num2, 6]\n    }\n\n    if (row.names(heatmapmatrix)[i] %in% shared$Description) {\n      num3 <- which(shared$Description == row.names(heatmapmatrix)[i])\n      heatmapmatrix[i, 3] <- shared[num3, 6]\n    }\n  }\n\n  # places the adjusted p-value in the matrix is there is one\n\n  if (removeonlyshared == TRUE) {\n    # finds the shared pathways the are not present in up or down\n    mycounts <- as.numeric(apply(heatmapmatrix,\n                                 1,\n                                 function(x) is.na(x[1]) & is.na(x[2])))\n    # keeps those that are not only shared\n    heatmapinput <- heatmapmatrix[mycounts == 0, ]\n  }\n  if (removeonlyshared == FALSE) {\n    heatmapinput <- heatmapmatrix\n  }\n\n\n  heatmapdata <- as.data.frame(heatmapinput)\n  heatmapdata <- heatmapdata[order(heatmapdata$down,\n                                   heatmapdata$up,\n                                   heatmapdata$shared,\n                                   decreasing = TRUE), ]\n  # sorts matrix\n  heatmapdata$id <- rownames(heatmapdata)\n  # makes id\n  rownames(heatmapdata) <- c(1:nrow(heatmapdata))\n\n\n  suppressMessages(meltedheatmapdata <- reshape2::melt(heatmapdata))\n\n  meltedheatmapdata$newid <- stringr::str_wrap(meltedheatmapdata$id, width = 80)\n\n  meltedheatmapdata$id <- factor(meltedheatmapdata$id,\n                                 levels = unique(meltedheatmapdata$id))\n\n  theXAxis <- as.character(meltedheatmapdata[,2])\n  theYAxis <- meltedheatmapdata[,4]\n  #all possible values of X (type) and Y (pathways)\n\n  theUniqueY <- unique(meltedheatmapdata$newid)\n  theUniqueX <- c(\"up\", \"down\", \"shared\")\n  #unique values of X and Y\n\n\n  for (i in 0:(length(theUniqueY) - 1))\n  {\n    num <- which(theYAxis == theUniqueY[i + 1])\n    theYAxis[num] <- i\n  }\n  for (i in 0:(length(theUniqueX) - 1))\n  {\n    num <- which(theXAxis == theUniqueX[i + 1])\n    theXAxis[num] <- i\n  }\n  #Subsitute words with position on the matrix\n\n  dataforHeatmap <- as.data.frame(cbind(as.numeric(theXAxis),\n                                      as.numeric(theYAxis),\n                                      round(as.numeric(meltedheatmapdata$value)\n                                              ,3)))\n  formattedHeatmapData <- list_parse2(dataforHeatmap)\n  #create final formatting\n\n  hc <- highchart() %>%\n    hc_chart(type = \"heatmap\") %>%\n    hc_title(text = title) %>%\n    hc_xAxis(categories = theUniqueX) %>%\n    hc_yAxis(categories = theUniqueY) %>%\n    hc_add_series(name = \"matrix location, p-value\",\n                  data = formattedHeatmapData) %>%\n    hc_legend(\n      title = \"p-value\",\n      enabled = TRUE\n    ) %>%\n    hc_exporting(enabled = TRUE)\n  p <- hc_colorAxis(hc, minColor = \"#000080\", maxColor = \"#FFFFFF\")\n  #create final formatting\n\n  return(p)\n  }\n\n\n##############################################################################\n\n#' Given the output from processPathways(), creates a heatmap from\n#' the ouput of the GREAT enrichment analysis. Presence or absence of\n#' the pathway in enrichment of both type-specific (increased or decreased\n#' log2fold change, low p-value) and shared (no change, higher p-value)\n#' regulatory regions is plotted.\n#'\n#' @param input results from GREAT enrichment analysis\n#' @param title title of the heatmap\n#' @param pathwaycateg ontology\n#' @param numshow number of top pathways (ranked according to p-value) of each type (expt, reference, shared) to show in the plot (default=10)\n#'\n#' @return heatmap\n#'\n#' @examples\n#' \\dontrun{\n#' csvfile <- file.path(dir=\"yourfilepath\", 'sampleinfo.csv')\n#' sampleinfo <- loadCSVFile(csvfile)\n#' samplePeaks <- loadBedFiles(sampleinfo)\n#' consPeaks <- getConsensusPeaks(samplepeaks = samplePeaks, minreps = 2)\n#' plotConsensusPeaks(samplepeaks = consPeaks)\n#' TSSannot <- getTSS()\n#' consPeaksAnnotated <- combineAnnotatePeaks(conspeaks = consPeaks,\n#'                                           TSS = TSSannot,\n#'                                           merge = TRUE,\n#'                                           regionspecific = TRUE,\n#'                                           distancefromTSSdist = 1500,\n#'                                           distancefromTSSprox = 1000)\n#' counts_consPeaks <- getCounts(annotpeaks = consPeaksAnnotated,\n#'                               sampleinfo = sampleinfo,\n#'                               reference = 'SAEC',\n#'                               chrom = 'chr21')\n#' altre_peaks <- countanalysis(counts=counts_consPeaks,\n#'                              pval=0.01,\n#'                              lfcvalue=1)\n#' categaltre_peaks <- categAltrePeaks(altre_peaks,\n#'                              lfctypespecific = 1.5,\n#'                              lfcshared = 1.2,\n#'                              pvaltypespecific = 0.01,\n#'                              pvalshared = 0.05)\n#' GREAToutput <- runGREAT(peaks=categaltre_peaks)\n#' GREATpathways <- processPathways(temp)\n#' names(GREATpathways$Sig_Pathways)\n#' plot <- plotGREATenrich(GREATpathways, title=\"GREAT Enrichment Analysis\", pathwaycateg=\"GO Molecular Function\")\n#' }\n#'\n#' @export\n\nplotGREATenrich <- function(){}\n###plotGREATenrich <- function(input,\n###                          title,\n###                          pathwaycateg,\n###                          numshow=10) {\n###\n###\n###  if (is.list(input) == FALSE) {\n###    stop(\"The input is not a list! Please make sure you are\n###         using the output from the enrichment analysis (function processPathways())\")\n###\n###  if (is.data.frame(input$expt) == FALSE |\n###      is.data.frame(input$reference) == FALSE |\n###      is.data.frame(input$shared) == FALSE |\n###      length(input) != 3 |\n###      all(names(input) != c(\"expt\", \"reference\", \"shared\"))) {\n###    stop(\"The input is not a list of three dataframes or\n###         there are no enriched pathways to plot\")\n###  }\n\n\n\n\n\n\n\n\n\n#' Plots a venn diagram that compares altered regions as determined by peak presence or by\n#' differential counts.  The type of regulatory region (TSS-proximal, TSS-distal, or both)\n#' and type of peak comparison (intensity or peak) must be specified.\n#' Plots a venn diagram that compares altered regions as determined by peak\n#' presence or by differential counts.  The type of regulatory region\n#' (TSS-proximal, TSS-distal, or both) and type of peak comparison\n#' (intensity or peak) must be specified.\n#' @param analysisresultsmatrix analysisresults of Intensity analysis place into\n#' analysisresults matrix by the analyzeanalysisresults function\n#' @param region pick a region, regions can be 'TSS-distal', 'TSS-proximal',\n#' or 'both' -- INCLUDE quotes\n#' @param method pick a method, methods can be 'Intensity' or 'Peak'\n#' include quotes\n#' @param palette RColorBrewer palette to change graph colors\n#' @return venn diagram\n#' @examples\n#' \\dontrun{\n#' csvfile <- loadCSVFile(\"DNAseEncodeExample.csv\")\n#' samplePeaks <- loadBedFiles(csvfile)\n#' consensusPeaks <- getConsensusPeaks(samplepeaks = samplePeaks,\n#' minreps = 2)\n#' TSSannot <- getTSS()\n#' consensusPeaksAnnotated <- combineAnnotatePeaks(conspeaks = consensusPeaks,\n#' TSS = TSSannot,\n#' merge = TRUE,\n#' regionspecific = TRUE,\n#' distancefromTSSdist = 1500,\n#' distancefromTSSprox = 1000)\n#' consensusPeaksCounts <- getCounts(annotpeaks = consensusPeaksAnnotated,\n#'                                  sampleinfo = csvfile,\n#'                                  reference = 'SAEC',\n#'                                  chrom = 'chr21')\n#' alteredPeaks <- countanalysis(counts = consensusPeaksCounts,\n#' pval = 0.01,\n#' lfcvalue = 1)\n#' alteredPeaksCategorized <- categAltrePeaks(alteredPeaks,\n#'                                           lfctypespecific = 1.5,\n#'                                           lfcshared = 1.2,\n#'                                           pvaltypespecific = 0.01,\n#'                                           pvalshared = 0.05)\n#'plotCompareMethods(comparePeaksAnalysisResults)\n#'}\n\nplotCompareMethods <- function(analysisresultsmatrix,\n                     region = \"both\", method = \"Intensity\", palette = NULL) {\n\n\n  if ( !is.null(palette) ) {\n    cols <- RColorBrewer::brewer.pal(3, palette) }\n  else{cols <- c(\"#00E5EE\", \"#C71585\",\"#000080\")}\n\n  if (region == \"TSS-proximal\") {\n    feature <- c(\"TSS-proxs\")\n    coordinates <- c(2, 5, 8)\n  }\n  if (region == \"TSS-distal\") {\n    feature <- c(\"TSS-dists\")\n    coordinates <- c(1, 4, 7)\n  }\n  if (region == \"both\") {\n    region <- c(\"All\")\n    feature <- c(\"TSS-dists\", \"TSS-proxs\")\n    coordinates <- c(3, 6, 9)\n  }\n  # identifies the correct numbers from the\n  # analysisresults matrix based on the\n  # regulatory region of interest\n  if (method == \"Intensity\") {\n    case <- analysisresultsmatrix[coordinates[1], 1]\n    reference <- analysisresultsmatrix[coordinates[2], 1]\n    shared <- analysisresultsmatrix[coordinates[3], 1]\n  }\n\n  if (method == \"Peak\") {\n    case <- analysisresultsmatrix[coordinates[1], 2]\n    reference <- analysisresultsmatrix[coordinates[2], 2]\n    shared <- analysisresultsmatrix[coordinates[3], 2]\n  }\n  # identifies the correct numbers from the\n  # analysisresults matrix based on the\n  # method of region\n  string <- paste(rownames(analysisresultsmatrix)[1],\n                  rownames(analysisresultsmatrix)[2],\n                  rownames(analysisresultsmatrix)[3],\n                  rownames(analysisresultsmatrix)[4],\n                  rownames(analysisresultsmatrix)[5],\n                  rownames(analysisresultsmatrix)[6],\n                  rownames(analysisresultsmatrix)[7],\n                  rownames(analysisresultsmatrix)[8],\n                  rownames(analysisresultsmatrix)[9])\n\n  stringsplit <- strsplit(string, \" \")\n  uniquestringsplit <- unique(stringsplit[[1]])\n  split <- unlist(strsplit(rownames(analysisresultsmatrix)[1], split = \" \"))\n  names <- split[!(split %in% c(\"TSS-dists\"))]\n  names <- paste(names, collapse = \" \")\n  casename <- names\n\n  split <- unlist(strsplit(rownames(analysisresultsmatrix)[4], split = \" \"))\n  names <- split[!(split %in% c(\"TSS-dists\"))]\n  names <- paste(names, collapse = \" \")\n  referencename <- names\n\n  # this is a way to the name of the 'case'\n  # from the analysisresults matrix\n\n  p <- highchart(height = 700) %>%\n    hc_chart(type = \"pie\") %>%\n    hc_title(text = paste(region, method),\n             style = list(color = '#2E1717',\n                          fontWeight = 'bold')) %>%\n    hc_plotOptions(\n      series = list(showInLegend = TRUE)\n    ) %>%\n    hc_legend(\n      enabled = TRUE,\n      layout = \"horizontal\",\n      align = \"center\",\n      verticalAlign = \"bottom\",\n      floating = FALSE,\n      maxHeight = 100,\n      x = 0,\n      y = 16\n    ) %>%\n    hc_add_series(data = list(\n      list(y = case, name = casename, dataLabels = FALSE),\n      list(y = reference, name = referencename, dataLabels = FALSE),\n      list(y = shared, name = \"Shared\", dataLabels = FALSE)\n    ), name = paste(region, method)) %>%\n    hc_colors(cols)  %>%\n    hc_exporting(enabled = TRUE)\n  return(p)\n}\n\n#' Plots venn diagrams for comparison of two methods of identifying altered\n#' regulatory regions Makes venn diagrams for TSS-proximal, TSS-distal, and\n#' combined for both intensity-based peaks and for peaks identified by hotspot\n#' calling algorithms.  There is no return value. Six venn diagrams will be\n#' plotted\n#' @param analysisresultsmatrix analysisresults of countanalysis function\n#' place into a a analysisresults matrix by the analyzeanalysisresults function\n#' @param viewer whether the plot should be displayed in the RStudio viewer or\n#' in Shiny/Knittr\n#' @param palette RColorBrewer palette to change graph colors\n#' @examples\n#' \\dontrun{\n#' csvfile <- loadCSVFile(\"DNAseEncodeExample.csv\")\n#' samplePeaks <- loadBedFiles(csvfile)\n#' consensusPeaks <- getConsensusPeaks(samplepeaks = samplePeaks,\n#' minreps = 2)\n#' TSSannot <- getTSS()\n#' consensusPeaksAnnotated <- combineAnnotatePeaks(conspeaks = consensusPeaks,\n#' TSS = TSSannot,\n#' merge = TRUE,\n#' regionspecific = TRUE,\n#' distancefromTSSdist = 1500,\n#' distancefromTSSprox = 1000)\n#' consensusPeaksCounts <- getCounts(annotpeaks = consensusPeaksAnnotated,\n#'                                  sampleinfo = csvfile,\n#'                                  reference = 'SAEC',\n#'                                  chrom = 'chr21')\n#' alteredPeaks <- countanalysis(counts = consensusPeaksCounts,\n#' pval = 0.01,\n#' lfcvalue = 1)\n#' alteredPeaksCategorized <- categAltrePeaks(alteredPeaks,\n#'                                           lfctypespecific = 1.5,\n#'                                           lfcshared = 1.2,\n#'                                           pvaltypespecific = 0.01,\n#'                                           pvalshared = 0.05)\n#'plotCompareMethodsAll(comparePeaksAnalysisResults)\n#' }\n#' @export\n#'\nplotCompareMethodsAll <- function(analysisresultsmatrix, viewer = TRUE,\n                                  palette = NULL) {\n\n\n  if ( !is.null(palette) ) {\n    cols <- RColorBrewer::brewer.pal(3, palette) }\n  else{cols <- c(\"#00E5EE\", \"#C71585\",\"#000080\")}\n\n  analysisresultsmatrix <- analysisresultsmatrix[[1]]\n\n  if (is.matrix(analysisresultsmatrix) ==\n      FALSE) {\n    stop(\"The input is not a matrix!\")\n  }\n\n  p1 <- plotCompareMethods(analysisresultsmatrix,\n                    \"TSS-proximal\", \"Intensity\", palette = palette)\n  p2 <- plotCompareMethods(analysisresultsmatrix,\n                    \"TSS-distal\", \"Intensity\", palette = palette)\n  p3 <- plotCompareMethods(analysisresultsmatrix,\n                    \"both\", \"Intensity\", palette = palette)\n  p4 <- plotCompareMethods(analysisresultsmatrix,\n                    \"TSS-proximal\", \"Peak\", palette = palette)\n  p5 <- plotCompareMethods(analysisresultsmatrix,\n                    \"TSS-distal\", \"Peak\", palette = palette)\n  p6 <- plotCompareMethods(analysisresultsmatrix,\n                    \"both\", \"Peak\", palette = palette)\n\n  if (viewer == TRUE) {\n    p <- htmltools::browsable(hw_grid(p1, p2, p3, p4, p5, p6, ncol = 3,\n                                      rowheight = 300))\n  }\n  else {\n    p <- hw_grid(p1, p2, p3, p4, p5, p6, ncol = 3)\n  }\n  return(p)\n\nreturn(p)\n}\n\n",
    "created" : 1472137681383.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4282376061",
    "id" : "AFA1A4B8",
    "lastKnownWriteTime" : 1472660647,
    "last_content_update" : 1472660647912,
    "path" : "~/Desktop/ALTRE/R/plottingfunctions.R",
    "project_path" : "R/plottingfunctions.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}
{
    "collab_server" : "",
    "contents" : "#' Enrichment analysis using GREAT package\n#' to identify putative pathways of interest for further\n#' investigation\n#' @param peaks list, output of categAltrePeaks() function\n#' #@param peaktype character, \"Experiment Specific\", \"Reference Specific\",\n#' #\t\"Ambiguous\", \"Shared\", or \"All\" (All is default)\n#' @param species default hg19\n#' @param rule character, \"basalPlusExt\", \"twoClosest\", \"oneClosest\" rule that associates\n#' \tgenomic regions to genes (default is \"basalPlusExt\").\n#' \tSee https://bioconductor.org/packages/release/bioc/html/chipenrich.html for more detail.\n#' @param adv_upstream kb, extension to upstream (if rule is basalPlusExt), default 5\n#' @param adv_downstream kb, extension to downstream (if rule is basalPlusExt), default 1.0\n#' @param adv_span kb, max extension (if rule is basalPlusExt), default 1000.0\n#' @param adv_twoDistance kb, max extension (if rule is twoClosest), default 1000.0\n#' @param adv_oneDistance kb, max extension (if rule is oneClosest), default 1000.0\n#' @param pathway_category character, \"GO\", \"Pathway Data\", \"Regulatory Motifs\",\n#'\t\"Phenotype Data and Human Disease\", \"Gene Expression\", \"Gene Families\"\n#'\t(default is \"GO\")\n#' @examples\n#' \\dontrun{\n#' csvfile <- loadCSVFile(\"DNAseEncodeExample.csv\")\n#' samplePeaks <- loadBedFiles(csvfile)\n#' consensusPeaks <- getConsensusPeaks(samplepeaks = samplePeaks, minreps = 2)\n#' TSSannot <- getTSS()\n#' consensusPeaksAnnotated <- combineAnnotatePeaks(conspeaks = consensusPeaks,\n#'                                           TSS = TSSannot,\n#'                                           merge = TRUE,\n#'                                           regionspecific = TRUE,\n#'                                           distancefromTSSdist = 1500,\n#'                                           distancefromTSSprox = 1000)\n#' consensusPeaksCounts <- getCounts(annotpeaks = consensusPeaksAnnotated,\n#'                               reference = 'SAEC',\n#'                               sampleinfo = csvfile,\n#'                               chrom = 'chr21')\n#' alteredPeaks <- countanalysis(counts=consensusPeaksCounts,\n#'                              pval=0.01,\n#'                              lfcvalue=1)\n#' alteredPeaksCategorized <- categAltrePeaks(alteredPeaks,\n#'                              lfctypespecific = 1.5,\n#'                              lfcshared = 1.2,\n#'                              pvaltypespecific = 0.01,\n#'                              pvalshared = 0.05)\n#' callPaths <- runGREAT(peaks = alteredPeaksCategorized)\n#' }\n#' @return ways --\n#' pathways also annotated with additional information\n# run with categaltre_peaks\n#' @export\n#'\nrunGREAT <- function(peaks,\n                     #\tpeaktype=\"All\",\n                     species = \"hg19\",\n                     rule = \"basalPlusExt\",\n                     adv_upstream = 5.0,\n                     adv_downstream = 1.0,\n                     adv_span = 1000.0,\n                     adv_twoDistance = 1000.0,\n                     adv_oneDistance = 1000.0,\n                     pathway_category = \"GO\") {\n  # Check that peaktype entry is allowable and grab peaks for analysis\n  #  if (is.na(match(peaktype,c(\"All\",\"Experiment Specific\", \"Shared\", \"Ambiguous\",\n  #\t\"Reference Specific\")))) {\n  #\tstop(\"peaktype should be either 'All', 'Experiment Specific', 'Shared',\n  #\t\t'Ambiguous', or 'Reference Specific'\")\n  #  }\n  #  if (peaktype == \"All\") {\n  #\tmypeaks = as.data.frame(peaks$analysisresults)[,c(\"chr\",\"start\",\"stop\")] }\n  #  else {\n  #\tmypeaks = as.data.frame(peaks$analysisresults)[which(peaks$analysisresults==peaktype),\n  #\t\tc(\"chr\",\"start\",\"stop\")]}\n  if (is.na(match(rule, c(\n    \"basalPlusExt\", \"twoClosest\", \"oneClosest\"\n  )))) {\n    stop(\"rule must be either 'basalPlusExt', 'twoClosest', 'oneClosest'\")\n  }\n\n  mygreat = list()\n  for (i in c(\"ExperimentSpecificByIntensity\", \"ReferenceSpecificByIntensity\", \"Shared\")) {\n    #print(paste(\"Running\", i))\n    mypeaks <- as.data.frame(peaks$analysisresults)[\n      which(peaks$analysisresults$REaltrecateg == i),\n      c(\"chr\", \"start\", \"stop\")]\n    ilabel <- gsub(\" \", \"_\", i)\n    # Run GREAT\n    if (rule == \"basalPlusExt\") {\n      mygreat[[ilabel]] <- rGREAT::submitGreatJob(\n        mypeaks,\n        species = species,\n        adv_span = adv_span,\n        rule = \"basalPlusExt\",\n        adv_upstream = adv_upstream,\n        adv_downstream = adv_downstream,\n        request_interval = 20\n      )\n    }\n    if (rule == \"twoClosest\") {\n      mygreat[[ilabel]] <- rGREAT::submitGreatJob(\n        mypeaks,\n        species = species,\n        rule = \"twoClosest\",\n        adv_twoDistance = adv_twoDistance,\n        request_interval = 20\n      )\n    }\n    if (rule == \"oneClosest\") {\n      mygreat[[ilabel]] <- rGREAT::submitGreatJob(\n        mypeaks,\n        species = species,\n        rule = \"oneClosest\",\n        adv_twoDistance = adv_oneDistance,\n        request_interval = 20\n      )\n    }\n  } # end looping through peak types\n  return(mygreat)\n} # end function\n\n\n#' Enrichment analysis using GREAT package\n#' to identify putative pathways of interest for further\n#' investigation\n#'\n#' @param GREATpath output of runGREAT()\n#' @param pathway_category character, \"GO\", \"Pathway Data\", \"Regulatory Motifs\",\n#'      \"Phenotype Data and Human Disease\", \"Gene Expression\", \"Gene Families\"\n#'      (default is \"GO\")\n#' @param enrichcutoff numeric, fold change enrichment cutoff to determine enriched pathways,\n#' default is 2\n#' @param adjpvalcutoff numeric, Bonferroni adjusted p-value cutoff to determine enriched pathways,\n#'\tdefault is 0.05\n#' @param adjustby character, \"fdr\" or \"bonferroni\", default is \"bonferroni\"\n#' @param test character, \"Both\" denotes hypergeometric and binomical tests are used to\n#' \tdetermine enriched pathways, \"Binom\" denotes binomial tests used, \"Hyper\" denotes\n#'\thypergeometric tests are used.  Default is \"Binom\"\n#'\n#' @return list of dataframes for enriched pathways - each dataframe in the list\n#' represents one pathway type (e.g. \"GO Molecular Function\")\n#' @examples\n#' \\dontrun{\n#' csvfile <- loadCSVFile(\"DNAseEncodeExample.csv\")\n#' samplePeaks <- loadBedFiles(csvfile)\n#' consensusPeaks <- getConsensusPeaks(samplepeaks = samplePeaks, minreps = 2)\n#' TSSannot <- getTSS()\n#' consensusPeaksAnnotated <- combineAnnotatePeaks(conspeaks = consensusPeaks,\n#'                                           TSS = TSSannot,\n#'                                           merge = TRUE,\n#'                                           regionspecific = TRUE,\n#'                                           distancefromTSSdist = 1500,\n#'                                           distancefromTSSprox = 1000)\n#' consensusPeaksCounts <- getCounts(annotpeaks = consensusPeaksAnnotated,\n#'                               reference = 'SAEC',\n#'                               sampleinfo = csvfile,\n#'                               chrom = 'chr21')\n#' alteredPeaks <- countanalysis(counts=consensusPeaksCounts,\n#'                              pval=0.01,\n#'                              lfcvalue=1)\n#' alteredPeaksCategorized <- categAltrePeaks(alteredPeaks,\n#'                              lfctypespecific = 1.5,\n#'                              lfcshared = 1.2,\n#'                              pvaltypespecific = 0.01,\n#'                              pvalshared = 0.05)\n#' callPaths <- runGREAT(peaks = alteredPeaksCategorized)\n#' pathResults <- processPathways(callPaths, pathway_category = \"GO\",\n#' enrichcutoff = 2, adjpvalcutoff = 0.05)\n#' }\n#' @export\n#'\nprocessPathways <- function(GREATpath,\n                            pathway_category = \"GO\",\n                            adjustby = \"bonferroni\",\n                            test = \"Binom\",\n                            enrichcutoff = 2,\n                            adjpvalcutoff = 0.05) {\n  finaloutput = list()\n  for (job in names(GREATpath)) {\n    if (!is(GREATpath[[job]], \"GreatJob\")) {\n      stop(\n        \"GREATpath is not a list of 'GreatJob' objects.\n        Input should be the output of runGREAT()\"\n      )\n    }\n\n    output <- rGREAT::getEnrichmentTables(GREATpath[[job]], category = pathway_category)\n    names(output) <- gsub(\" \", \"_\", names(output))\n    stats <- data.frame(Pathway = names(output),\n                       NumSig = rep(NA, length(names(output))))\n\n    for (i in names(output)) {\n\n      output[[i]]$Binom_adj_PValue <- stats::p.adjust(\n        output[[i]]$\"Binom_Raw_PValue\",\n        method = adjustby)\n\n      output[[i]]$Hyper_adj_PValue <- stats::p.adjust(\n        output[[i]]$\"Hyper_Raw_PValue\",\n        method = adjustby)\n\n      if (test == \"Both\") {\n        keepers <- base::Reduce(intersect, list(\n          which(output[[i]]$Binom_Fold_Enrichment > enrichcutoff),\n          which(output[[i]]$Hyper_Fold_Enrichment >\n                  enrichcutoff),\n          which(output[[i]]$Binom_adj_PValue <=\n                  adjpvalcutoff),\n          which(output[[i]]$Hyper_adj_PValue <=\n                  adjpvalcutoff)\n        ))\n      }\n      else if (test == \"Binom\") {\n        keepers <- base::Reduce(intersect,\n                                list(\n                                  which(output[[i]]$Binom_Fold_Enrichment\n                                        > enrichcutoff),\n                                  which(output[[i]]$Binom_adj_PValue\n                                        <= adjpvalcutoff)\n                                  )\n                                )\n      }\n      else if (test == \"Hyper\") {\n        keepers <- base::Reduce(intersect, list(\n          which(output[[i]]$Hyper_Fold_Enrichment > enrichcutoff),\n          which(output[[i]]$Hyper_adj_PValue <=\n                  adjpvalcutoff)\n        ))\n      }\n      else {\n        stop(\"test should be 'Both', 'Binom', or 'Hyper'\")\n      }\n      #print(length(keepers))\n      output[[i]] <- output[[i]][keepers, ]\n      output[[i]] <- output[[i]][base::order(output[[i]]$Binom_adj_PValue), ]\n      stats$NumSig[which(stats$Pathway == i)] <-\n        length(which(output[[i]]$Binom_adj_PValue <= adjpvalcutoff))\n    }\n    finaloutput[[job]] <- list(Sig_Pathways = output, stats = stats)\n    } # end looping through each GREAT job\n  return(finaloutput)\n} # end function\n",
    "created" : 1473863230407.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2275831074",
    "id" : "E78565AB",
    "lastKnownWriteTime" : 1473863289,
    "last_content_update" : 1473863289336,
    "path" : "~/Desktop/ALTRE/R/8a_runGREAT.R",
    "project_path" : "R/8a_runGREAT.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}